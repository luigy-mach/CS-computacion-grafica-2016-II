#include <GL/glut.h>

#include <iostream>
#include <math.h>


void reshape(int width, int height)
{
  glViewport(0, 0, width, height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-30, 30, -30, 30, -30, 30);
  // glOrtho(-50, 50, -50, 50, -50, 50);
  //glOrtho(-300, 300, -300, 300, -300, 300);
  glMatrixMode(GL_MODELVIEW);
}


void split(float *p,int n){
  float pi=3.141516;
  float div = 2*pi/static_cast< float >(n);
  float temp=0;
  // std::cout<<"-->>"<<div<<std::endl;
  for(int i=0;i<=n;i++){
    temp+=div;
    p[i]=temp;
    //p[i]=i;
    // std::cout<<"//"<<p[i]<<std::endl;
  }
  // std::cout<<"split ok"<<std::endl;
}

void points(float **&pp,float *p ,  int n, float radio=1.0 ){
  float pi=3.141516;
  pp=new float*[n];
  for(int i=0;i<n;i++){
    pp[i]=new float[2];
  }
  for(int i=0;i<n;i++){
    if(p[i]<=pi){
      pp[i][0]=radio*cos(pi-p[i]);
      // std::cout<<"**"<<pp[i][0]<<std::endl;
      pp[i][1]=radio*sin(pi-p[i]);
      // std::cout<<"**"<<pp[i][1]<<std::endl;
    }
    else {
      pp[i][0]=radio*cos(2*pi-p[i]);
      // std::cout<<"***"<<pp[i][0]<<std::endl;
      pp[i][1]=radio*sin(2*pi-p[i]);
      // std::cout<<"***"<<pp[i][1]<<std::endl;
    }
  }

  // std::cout<<"points ok"<<std::endl;



}


void glPolygon( unsigned int sides )
{
  if( sides < 3 ) return;

  const float PI = 3.14159;
  const float step = ( 2 * PI ) / static_cast< float >( sides );

  glBegin( GL_LINE_LOOP );
  for( unsigned int i = 0; i < sides; ++i )
  {
    glVertex2f( cos( i * step ), sin( i * step ) );
  }
  glEnd();
}


void display2()
{
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f(1,1,1);
  glLoadIdentity();
  glBegin(GL_LINES);

  int n=3;
  float theta=0;
  float alpha=0;
  float **pp=NULL;
  float *p=NULL;
  p=new float[n];

  for(int i=0;i<n;i++){
    p[i]=-1;
  }
  split(p,n);

  points(pp,p,n,2);

	int x=0;
	int y=0;

  glBegin( GL_LINE_LOOP );
  for( unsigned int i = 0; i < n; ++i )
  {
    // glVertex2f(pp[i][0],pp[i][1] );
   // glVertex3f(pp[i][0],pp[i][1],0);
    y++;
    x++;
    glVertex3f(cos(x*i/2),sin(y*i*i/2),0);

    //std::cout<<pp[i][0]<<" mas1 "<<pp[i][1]<<std::endl;

  }
  glEnd();

  // glBegin( GL_LINE_LOOP );
  //  for(int i=0;i<n;i++){
  //     glVertex3f(pp[i][0],pp[i][1],0);
  //     // std::cout<<"mas1"<<std::endl;
  //    if((i+1)==n){
  //     //  glVertex3f(i+3,i+3,0);
  //      glVertex3f(pp[0][0],pp[0][1],0);
  //     //  std::cout<<"fin dibujar lineas"<<std::endl;
  //    }
  //    else{
  //     //  glVertex3f(i+6,i+9,0);
  //      glVertex3f(pp[i+1][0],pp[i+1][1],0);
  //     //  std::cout<<"mas2"<<std::endl;
  //    }
  //
  //  }
  // glEnd();
  // // std::cout<<"for ok"<<std::endl;

  // std::cout<<"final ok"<<std::endl;

  glEnd();
  glFlush();


}

void display()
{
  // glClear(GL_COLOR_BUFFER_BIT);
  // glColor3f(1,1,1);
  // glLoadIdentity();
  // glBegin(GL_LINES);
  //
  //
  // glEnd();
  // glFlush();

  glClear( GL_COLOR_BUFFER_BIT );
  glMatrixMode( GL_PROJECTION );

  glLoadIdentity();
  float ar = glutGet( GLUT_WINDOW_WIDTH ) / (float)glutGet( GLUT_WINDOW_HEIGHT );
  glOrtho( -2 * ar, 2 * ar, -2, 2, -1, 1);

  glMatrixMode( GL_MODELVIEW );
  glLoadIdentity();

  glColor3ub( 255, 0, 0 );
  // glPolygon( 8 );
  display2();
  glutSwapBuffers();
}





void init()
{
  glClearColor(0,0,0,0);
}


int main(int argc, char **argv)
{


  int tam=600;
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowPosition(20, 0);
  glutInitWindowSize(tam, tam);
  glutCreateWindow("Hello OpenGL");
  init();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}
